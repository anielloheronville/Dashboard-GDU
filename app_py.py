# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KEH6F6vgjaHVxMl-E5VdOJT5PkR_9pve
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import gamma
from datetime import timedelta, datetime

# =============================================================================
# SE√á√ÉO 1: FUN√á√ïES DO MODELO DE SIMULA√á√ÉO (L√≥gica Principal)
# =============================================================================

def atualizar_parametros_cultura(gdu_acumulado, cfg):
    """Atualiza dinamicamente os par√¢metros da cultura com base na fenologia (GDU)."""
    if gdu_acumulado < cfg['gdu_fase_reprodutiva_inicial']:
        albedo = 0.20
        fator_crescimento_raiz = gdu_acumulado / cfg['gdu_fase_reprodutiva_inicial']
        prof_raiz_efetiva = cfg['profundidade_camada1'] + (cfg['profundidade_camada2'] * fator_crescimento_raiz)
    elif gdu_acumulado < cfg['gdu_fase_reprodutiva_pico']:
        albedo = 0.23
        prof_raiz_efetiva = cfg['profundidade_camada1'] + cfg['profundidade_camada2']
    else:
        albedo = 0.21
        prof_raiz_efetiva = cfg['profundidade_camada1'] + cfg['profundidade_camada2']
    prof_max = cfg['profundidade_camada1'] + cfg['profundidade_camada2']
    return albedo, min(prof_raiz_efetiva, prof_max)

def simular_processos_diarios(n_dias, start_day_of_year, latitude_rad, altitude, cfg):
    """Executa a simula√ß√£o di√°ria para uma safra completa."""
    precipitacao, eto_arr, gdu_padrao, gdu_ajustado, dias_estresse, runoff = (np.zeros(n_dias) for _ in range(6))
    estado_chuva, estado_nebulosidade = (np.zeros(n_dias, dtype=np.int64) for _ in range(2))
    armazenamento_c1, armazenamento_c2 = (np.zeros(n_dias) for _ in range(2))
    armazenamento_c1[0] = cfg['capacidade_max_camada1'] * 0.8
    armazenamento_c2[0] = cfg['capacidade_max_camada2'] * 0.8
    gdu_acumulado = 0.0

    for i in range(1, n_dias):
        if np.random.rand() < cfg['P_chuva'][estado_chuva[i-1], 1]: estado_chuva[i] = 1
        precipitacao[i] = gamma.rvs(a=cfg['formato_gama'], scale=cfg['escala_gama']) if estado_chuva[i] == 1 else 0.0

        day_index = start_day_of_year + i
        temp_media_sazonal = cfg['temp_media_anual'] + cfg['amplitude_sazonal'] * np.sin(2 * np.pi * day_index / 365.25)
        fator_neb_temp = 0.6 if estado_nebulosidade[i] == 1 else 1.0
        amp_diurna = cfg['amplitude_diurna_base'] * fator_neb_temp
        t_max = temp_media_sazonal + amp_diurna / 2 + np.random.normal(0, 1.0)
        t_min = t_max - amp_diurna - np.random.normal(0, 1.0)
        t_mean = (t_max + t_min) / 2
        albedo, prof_raiz_efetiva = atualizar_parametros_cultura(gdu_acumulado, cfg)

        sigma = 4.903e-9; G = 0; P = 101.3 * ((293 - 0.0065 * altitude) / 293)**5.26; gamma_p = 0.000665 * P
        e_tmax = 0.6108 * np.exp((17.27 * t_max) / (t_max + 237.3)); e_tmin = 0.6108 * np.exp((17.27 * t_min) / (t_min + 237.3))
        es = (e_tmax + e_tmin) / 2; ea = (np.random.uniform(80, 95) / 100) * es if estado_chuva[i] == 1 else (np.random.uniform(55, 75) / 100) * es
        delta_v = 4098 * (0.6108 * np.exp((17.27 * t_mean) / (t_mean + 237.3))) / (t_mean + 237.3)**2
        dr = 1 + 0.033 * np.cos(2 * np.pi / 365 * day_index); delta_sol = 0.409 * np.sin(2 * np.pi / 365 * day_index - 1.39)
        omega_s = np.arccos(-np.tan(latitude_rad) * np.tan(delta_sol))
        Ra = (24 * 60 / np.pi) * 0.0820 * dr * (omega_s * np.sin(latitude_rad) * np.sin(delta_sol) + np.cos(latitude_rad) * np.cos(delta_sol) * np.sin(omega_s))
        n_N_ratio = 0.35 if estado_nebulosidade[i] == 1 else 0.8; Rs = Ra * (cfg['a_s'] + cfg['b_s'] * n_N_ratio)
        Rso = (0.75 + 2e-5 * altitude) * Ra; Rns = (1 - albedo) * Rs
        t_max_k4 = (t_max + 273.16)**4; t_min_k4 = (t_min + 273.16)**4
        Rnl = sigma * ((t_max_k4 + t_min_k4) / 2) * (0.34 - 0.14 * np.sqrt(ea)) * (1.35 * (Rs / Rso) - 0.35)
        Rn = Rns - Rnl; u2 = np.random.uniform(1.0, 3.0)
        termo1 = (0.408 * delta_v * (Rn - G)); termo2 = (gamma_p * (900 / (t_mean + 273)) * u2 * (es - ea))
        denominador = (delta_v + gamma_p * (1 + 0.34 * u2))
        eto_arr[i] = max(0, (termo1 + termo2) / denominador)

        agua_c1_inicio = armazenamento_c1[i-1] + precipitacao[i]
        percolacao = max(0, agua_c1_inicio - cfg['capacidade_max_camada1']); armazenamento_c1_temp = agua_c1_inicio - percolacao
        agua_c2_inicio = armazenamento_c2[i-1] + percolacao
        runoff[i] = max(0, agua_c2_inicio - cfg['capacidade_max_camada2']); armazenamento_c2_temp = agua_c2_inicio - runoff[i]
        agua_disponivel_c1 = max(0, armazenamento_c1_temp - cfg['ponto_murcha_camada1']); agua_disponivel_c2 = max(0, armazenamento_c2_temp - cfg['ponto_murcha_camada2'])
        etr_c1 = min(agua_disponivel_c1, eto_arr[i] * 0.15)
        demanda_transpiracao = eto_arr[i] - etr_c1
        etr_c2 = min(agua_disponivel_c2, demanda_transpiracao) if prof_raiz_efetiva > cfg['profundidade_camada1'] else 0
        armazenamento_c1[i] = armazenamento_c1_temp - etr_c1; armazenamento_c2[i] = armazenamento_c2_temp - etr_c2

        gdu_padrao[i] = max(0, (min(t_max, cfg['T_MAX_LIMITE']) + max(t_min, cfg['T_BASE']))/2 - cfg['T_BASE'])
        cap_disponivel_total_raiz = (cfg['capacidade_max_camada1'] - cfg['ponto_murcha_camada1']) + (cfg['capacidade_max_camada2'] - cfg['ponto_murcha_camada2'])
        agua_disponivel_total_raiz = max(0, armazenamento_c1[i] - cfg['ponto_murcha_camada1']) + max(0, armazenamento_c2[i] - cfg['ponto_murcha_camada2'])
        fator_umidade_relativa = agua_disponivel_total_raiz / cap_disponivel_total_raiz if cap_disponivel_total_raiz > 0 else 0
        umbral_estresse = 0.4
        fator_estresse = min(1.0, fator_umidade_relativa / umbral_estresse) if fator_umidade_relativa < umbral_estresse else 1.0

        if fator_estresse < 1.0: dias_estresse[i] = 1
        gdu_ajustado[i] = gdu_padrao[i] * fator_estresse
        gdu_acumulado += gdu_ajustado[i]

    return gdu_ajustado, dias_estresse, precipitacao, runoff

# =============================================================================
# SE√á√ÉO 2: FUN√á√ïES PARA EXECU√á√ÉO DA AN√ÅLISE E VISUALIZA√á√ÉO
# =============================================================================

@st.cache_data
def executar_analise_janelas(datas_plantio, ciclo_dias, n_simulacoes, config):
    """Executa a an√°lise de Monte Carlo para uma lista de datas de plantio."""
    resultados_janelas = []

    barra_progresso = st.progress(0, text="Iniciando simula√ß√£o...")
    status_texto = st.empty()

    for i, data_inicio in enumerate(datas_plantio):
        data_fim = data_inicio + timedelta(days=ciclo_dias - 1)
        status_texto.text(f"Simulando para a janela de plantio: {data_inicio.strftime('%Y-%m-%d')} a {data_fim.strftime('%Y-%m-%d')}")

        resultados_monte_carlo = []
        for _ in range(n_simulacoes):
            start_day_of_year = data_inicio.dayofyear
            latitude_rad = np.deg2rad(config['LATITUDE_GRAUS'])

            gdu_adj, estresse_dia, precip_dia, runoff_dia = simular_processos_diarios(
                ciclo_dias, start_day_of_year, latitude_rad, config['ALTITUDE_METROS'], config
            )

            metricas = {
                'gdu_final_ajustado': np.sum(gdu_adj),
                'dias_estresse_hidrico': np.sum(estresse_dia),
                'precipitacao_total_safra': np.sum(precip_dia),
                'runoff_total_safra': np.sum(runoff_dia)
            }
            resultados_monte_carlo.append(metricas)

        df_mc = pd.DataFrame(resultados_monte_carlo)
        medianas = df_mc.median()
        medianas['data_plantio'] = data_inicio.strftime('%Y-%m-%d')
        resultados_janelas.append(medianas)

        barra_progresso.progress((i + 1) / len(datas_plantio), text=f"Analisando janela {i+1}/{len(datas_plantio)}")

    status_texto.text("Simula√ß√£o conclu√≠da!")
    return pd.DataFrame(resultados_janelas).set_index('data_plantio')

def gerar_grafico(df_resultados):
    """Gera o gr√°fico comparativo a partir do DataFrame de resultados."""
    fig, ax1 = plt.subplots(figsize=(14, 8))

    sns.barplot(x=df_resultados.index, y='gdu_final_ajustado', data=df_resultados, ax=ax1, color='cornflowerblue', label='GDU Final Ajustado (Mediana)')
    ax1.set_xlabel('Data de Plantio', fontsize=12)
    ax1.set_ylabel('GDU Final Ajustado (Acumulado)', fontsize=12, color='cornflowerblue')
    ax1.tick_params(axis='y', labelcolor='cornflowerblue', labelsize=12)
    ax1.tick_params(axis='x', rotation=45, labelsize=12, ha="right")
    ax1.set_title('An√°lise de Janela de Plantio: GDU vs. Dias de Estresse H√≠drico', fontsize=16, pad=20)

    ax2 = ax1.twinx()
    sns.lineplot(x=df_resultados.index, y='dias_estresse_hidrico', data=df_resultados, ax=ax2, color='tomato', marker='o', lw=3, label='Dias de Estresse H√≠drico (Mediana)')
    ax2.set_ylabel('Dias de Estresse H√≠drico (Total)', fontsize=12, color='tomato')
    ax2.tick_params(axis='y', labelcolor='tomato', labelsize=12)

    lines, labels = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax2.legend(lines + lines2, labels + labels2, loc='upper left')
    ax1.get_legend().remove()

    plt.grid(False)
    plt.tight_layout()
    return fig

# =============================================================================
# SE√á√ÉO 3: INTERFACE DO USU√ÅRIO (Streamlit App)
# =============================================================================

st.set_page_config(layout="wide", page_title="Otimiza√ß√£o da Janela de Plantio")
st.title("üåΩ Dashboard de Otimiza√ß√£o da Janela de Plantio")
st.markdown("""
Esta ferramenta utiliza uma simula√ß√£o de Monte Carlo para analisar diferentes janelas de plantio.
O objetivo √© identificar as datas que maximizam o ac√∫mulo de Graus-Dia (GDU), um indicador de desenvolvimento da cultura,
enquanto minimizam os dias de estresse h√≠drico.
""")

st.sidebar.header("Par√¢metros da An√°lise")

st.sidebar.subheader("üóìÔ∏è Janelas de Plantio")
data_inicial_analise = st.sidebar.date_input("Data Inicial da An√°lise", datetime(2025, 10, 1))
data_final_analise = st.sidebar.date_input("Data Final da An√°lise", datetime(2026, 1, 15))
intervalo_dias = st.sidebar.slider("Intervalo entre datas (dias)", 7, 30, 15, help="Define o espa√ßamento entre as datas de plantio a serem testadas.")

datas_de_plantio_para_analise = pd.to_datetime(pd.date_range(start=data_inicial_analise, end=data_final_analise, freq=f'{intervalo_dias}D'))

st.sidebar.subheader("‚öôÔ∏è Par√¢metros da Simula√ß√£o")
ciclo_duracao_dias = st.sidebar.slider("Dura√ß√£o do Ciclo da Cultura (dias)", 90, 180, 150)
numero_de_simulacoes_por_janela = st.sidebar.slider("N√∫mero de Simula√ß√µes por Janela", 50, 500, 200, help="Maior n√∫mero aumenta a precis√£o, mas tamb√©m o tempo de processamento.")

with st.sidebar.expander("üî¨ Par√¢metros Avan√ßados do Modelo Agroclim√°tico"):
    st.markdown("Ajuste os par√¢metros base do modelo de simula√ß√£o.")
    T_BASE = st.number_input("Temperatura Base (¬∞C)", 5.0, 15.0, 10.0, 0.5)
    T_MAX_LIMITE = st.number_input("Temperatura M√°xima Limite (¬∞C)", 28.0, 40.0, 30.0, 0.5)
    gdu_fase_reprodutiva_inicial = st.number_input("GDU para In√≠cio da Fase Reprodutiva", 500.0, 1000.0, 700.0, 10.0)
    gdu_fase_reprodutiva_pico = st.number_input("GDU para Pico da Fase Reprodutiva", 1000.0, 1500.0, 1100.0, 10.0)
    escala_gama = st.number_input("Escala da Distribui√ß√£o Gama (Chuva)", 5.0, 15.0, 10.0, 0.5, help="Controla a intensidade m√©dia da chuva.")

config = {
    'P_chuva': np.array([[0.85, 0.15], [0.40, 0.60]]), 'P_nebulosidade': np.array([[0.7, 0.3], [0.4, 0.6]]),
    'formato_gama': 2.0, 'escala_gama': escala_gama,
    'profundidade_camada1': 200.0, 'profundidade_camada2': 800.0,
    'capacidade_max_camada1': 60.0, 'ponto_murcha_camada1': 20.0,
    'capacidade_max_camada2': 240.0, 'ponto_murcha_camada2': 80.0,
    'T_BASE': T_BASE, 'T_MAX_LIMITE': T_MAX_LIMITE,
    'gdu_fase_reprodutiva_inicial': gdu_fase_reprodutiva_inicial, 'gdu_fase_reprodutiva_pico': gdu_fase_reprodutiva_pico,
    'temp_media_anual': 26.0, 'amplitude_sazonal': 6.0, 'amplitude_diurna_base': 12.0,
    'LATITUDE_GRAUS': -12.5, 'ALTITUDE_METROS': 330, 'a_s': 0.25, 'b_s': 0.50,
}

if st.button("‚ñ∂Ô∏è Executar An√°lise de Janelas de Plantio"):
    if not datas_de_plantio_para_analise.empty:
        with st.spinner('Executando simula√ß√µes... Isso pode levar alguns minutos.'):
            df_resultados = executar_analise_janelas(
                datas_plantio=datas_de_plantio_para_analise,
                ciclo_dias=ciclo_duracao_dias,
                n_simulacoes=numero_de_simulacoes_por_janela,
                config=config
            )

        st.success("An√°lise conclu√≠da com sucesso!")

        st.subheader("üìä Resultados da Simula√ß√£o (Valores Medianos)")
        st.dataframe(df_resultados.round(1))

        st.subheader("üìà An√°lise Gr√°fica: GDU vs. Estresse H√≠drico")
        figura = gerar_grafico(df_resultados)
        st.pyplot(figura)

        st.subheader("üí° An√°lise e Conclus√£o")

        melhor_gdu_data = df_resultados['gdu_final_ajustado'].idxmax()
        melhor_gdu_valor = df_resultados['gdu_final_ajustado'].max()

        menor_estresse_data = df_resultados['dias_estresse_hidrico'].idxmin()
        menor_estresse_valor = df_resultados['dias_estresse_hidrico'].min()

        col1, col2 = st.columns(2)
        with col1:
            st.metric(
                label="Melhor Janela para GDU M√°ximo",
                value=melhor_gdu_data,
                delta=f"{melhor_gdu_valor:.1f} GDU"
            )
            st.markdown(f"A data de plantio em **{melhor_gdu_data}** resultou no maior ac√∫mulo mediano de Graus-Dia, indicando o maior potencial de desenvolvimento da cultura.")

        with col2:
            st.metric(
                label="Melhor Janela para Estresse M√≠nimo",
                value=menor_estresse_data,
                delta=f"{menor_estresse_valor:.0f} dias de estresse",
                delta_color="inverse"
            )
            st.markdown(f"A data de plantio em **{menor_estresse_data}** apresentou a menor quantidade mediana de dias sob estresse h√≠drico, favorecendo a sanidade da lavoura.")

        if melhor_gdu_data == menor_estresse_data:
            st.info(f"üèÜ **Recomenda√ß√£o:** A data de **{melhor_gdu_data}** parece ser a ideal, pois maximiza o GDU e minimiza o estresse h√≠drico simultaneamente.")
        else:
            st.warning(f"‚ö†Ô∏è **Aten√ß√£o:** Existe um trade-off. Para maximizar o GDU, a melhor data √© **{melhor_gdu_data}**. Para minimizar o estresse, a melhor data √© **{menor_estresse_data}**. A decis√£o final deve ponderar os riscos h√≠dricos versus o potencial produtivo.")

    else:
        st.error("O intervalo de datas selecionado n√£o gerou nenhuma janela de plantio. Por favor, ajuste as datas inicial e final.")